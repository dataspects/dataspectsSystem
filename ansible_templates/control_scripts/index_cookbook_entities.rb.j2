require 'dataspects'

module Dataspects

  class CookbookFALnetIndexer < Indexer

    def initialize(dataspects_api_url:, dataspects_api_key:, es_url:, tika_url:)
      super
      index = 'dataspectspublic'
      if(@esc.client.indices.exists?(index: index))
        @esc.client.indices.delete(index: index)
      end
      @esc.client.indices.create(index: index)
      @esc.client.indices.close(index: index)
      @esc.client.indices.put_settings(
        index: index,
        body: JSON.parse(File.read(
          'elasticsearch/standard_index_settings.json'))
      )
      @esc.client.indices.put_mapping(
        index: index,
        type: 'doc',
        body: JSON.parse(File.read(
          'elasticsearch/standard_index_mapping.json'))
      )
      @esc.client.indices.open(index: index)
    end

    def execute()
      # You need to create a api/mediawikis and puts its MongoDB ObjectID
      # here:
      ##########################################################
      ##########################################################
      response = RestClient.get(
        @dataspects_api_url+"/mediawikis?namespace=http://{{ mediawikiDomainNameInHostFile }}/wiki",
        headers = {
          "dataspects-api-key": @dataspects_api_key,
          content_type: :json,
          accept: :json
        }
      )
      mediawiki_id = JSON.parse(response.body)[0]['_id']
      ##########################################################
      ##########################################################
      response = RestClient.get(
        @dataspects_api_url+"/mediawikis/#{mediawiki_id}/pages",
        headers = {
          "dataspects-api-key": @dataspects_api_key,
          content_type: :json,
          accept: :json
        }
      )
      pages = JSON.parse(response)
      pages.each do |page|
        esdoc = {
          # Resource silo level
          OriginatedFromResourceSiloID: "",
          OriginatedFromResourceSiloLabel: "",
          OriginatedFromResourceSiloType: "",
          # Resource level
          OriginatedFromResourceName: page['pagename'],
          OriginatedFromResourceURL: "",
          OriginatedFromResourceType: "",
          # Entity/subject level
          HasEntityClass: page['hasEntityClass'],
          HasEntityName: page['hasEntityName'],
          HasEntityType: page['hasEntityType'],
          HasEntityURL: page['hasEntityURL'],
          HasEntityTitle: page['hasEntityTitle'],
          HasEntityBlurbTEXT: page['hasEntityBlurbTEXT'],
          HasEntityBlurbHTML: page['hasEntityBlurbHTML'],
          HasEntityContentTEXT: "",
          HasEntityContentHTML: page['nonFormssemanticizedWikitextHtml'],
          HasEntityTypeAndEntityTitle: "#{page['hasEntityType']} \"#{page['hasEntityTitle']}\"",
          HasEntityKeywords: page['hasEntityKeywords'],
          HasEntityAnnotations: page['annotations']
        }

        # EVERYTHING to Elasticsearch
        @esc.index(
          body: esdoc,
          index: "dataspectspublic"
        )

        # ANNOTATIONS as Annotations to MongoDB
        page['annotations'].each do |annotation|
          # annotation = {
          #           "_id" => "5c8f6eb5500c843c92dcf0e7",
          #            "id" => "subob",
          #       "subject" => "C0174167973",
          #     "predicate" => "ConcernsAspect",
          #        "object" => "Curation#"
          # }

        # This could be an Entity or an EntityType!
          temp = annotation['subject'].split('#0##') #FIXME: Lex: check for SMW subobject anonymous id!
          subject_page = get(
            url: @dataspects_api_url+"/mediawikis/pages/"+temp[0]
          )
          predicate = get(
            url: @dataspects_api_url+"/predicates/"+annotation['predicate']
          )
          object_page = get(
            url: @dataspects_api_url+"/mediawikis/pages/"+annotation['object']
          )

          ######################################################################
          ######################################################################
          ######################################################################
          # About SearchContexts
          # --------------------
          # When SearchContext is "Support", then only consider annotations whose subject_type or object_type have [[BelongsToSearchContext::Support]]

          # We assume subject_page is an Entity!
          subject_type_belongs_to_search_context = nil
          subjectType = subject_page['hasEntityType']
          if(subject_page['hasEntityType'].nil?)
            # But subject_page can be an EntityType!
            subject_type = get(
              url: @dataspects_api_url+"/mediawikis/pages/"+subject_page['pagename']
            )
            unless(subject_type['annotations'].empty?)
              #ASKCRAIG: Optimal retrieval approach?
              subject_type['annotations'].each do |annotation|
                if(annotation['predicate'] == "BelongsToSearchContext")
                  #TODO: These can be multiple!
                  subject_type_belongs_to_search_context = annotation['object']
                  subjectType = "EntityType"
                end
              end
            end
          end
          ######################################################################
          object_type_belongs_to_search_context = nil
          objectType = object_page['hasEntityType']
          if(object_page['hasEntityType'].nil?)
            object_type = get(
              url: @dataspects_api_url+"/mediawikis/pages/"+object_page['pagename']
            )
            unless(object_type['annotations'].empty?)
              object_type['annotations'].each do |annotation|
                if(annotation['predicate'] == "BelongsToSearchContext")
                  object_type_belongs_to_search_context = annotation['object']
                  objectType = "EntityType"
                end
              end
            end
          end
          ######################################################################
          ######################################################################
          ######################################################################

          mongodoc = {
            id: "test",
            subject: annotation['subject'],
            subject_namespace: page['mediaWiki']['namespace'],
            subject_class: "Entity|Subject", #
            subject_type: subjectType, #"Diagram|RubyGem" If annotation['subject'] exists in models:pagename then set to its hasEntityType
            subject_type_belongs_to_search_context: subject_type_belongs_to_search_context,
            predicate: annotation['predicate'],
            predicate_namespace: predicate['predicate_namespace'],
            predicate_class: predicate['predicate_class'], #"Property|ActiveAction|PassiveAction"
            predicate_type: predicate['predicate_type'], #"Text|Page|URL"
            object: annotation['object'],
            object_namespace: "literal", # If annotation['object'] exists in models:pagename then set to resource['mediaWiki']['namespace']
            object_class: "Entity|Subject|literal",
            object_type: objectType, #"Diagram|RubyGem|literal" If annotation['object'] exists in models:pagename then set to its hasEntityType
            object_type_belongs_to_search_context: object_type_belongs_to_search_context,
            context: "test"
          }
          post(
            url: @dataspects_api_url+"/annotations",
            body: mongodoc.to_json
          )
          $logger.info("Annotation fed to MongoDB")
        end
      end
    end

  end
end

# Run by "ruby index_cookbook_entities.rb"
$development_tika_url = "http://localhost:{{ tikaPortOnHost }}"
mwsi = Dataspects::CookbookFALnetIndexer.new(
  dataspects_api_url: "http://localhost:{{ dataspectsFeederServicePort }}/api",
  dataspects_api_key: "{{ ui_feed_service_api_key }}",
  tika_url: $development_tika_url,
  es_url: "http://localhost:{{ elasticsearchPortOnHost }}"
).execute
