require 'dataspects'
require 'awesome_print'

module Dataspects

  class Indexer

    def initialize(dataspects_api_url:, dataspects_api_key:, es_url:, tika_url:)
      @dataspects_api_url = dataspects_api_url
      @dataspects_api_key = dataspects_api_key
      @esc = ElasticsearchCluster.new(url: es_url)
      @tika_url = tika_url
    end

    def post(url:, body:)
      response = RestClient.post(
        url,
        body = body,
        headers = {
          "dataspects-api-key": @dataspects_api_key,
          content_type: :json,
          accept: :json
        }
      )
    end

    def get(url:)
      RestClient.get(
        URI.encode(url),
        headers = {
          "dataspects-api-key": @dataspects_api_key,
          content_type: :json,
          accept: :json
        }
      ) do |response, request, result|
        if(response.code == 404)
          return {'hasEntityType' => 'literal'}
        end
        return JSON.parse(response)
      end
    end

    def execute
      raise NotImplementedError.new
    end

  end

  class CookbookFALnetIndexer < Indexer

    def initialize(dataspects_api_url:, dataspects_api_key:, es_url:, tika_url:)
      super
      index = 'dataspectspublic'
      if(@esc.client.indices.exists?(index: index))
        @esc.client.indices.delete(index: index)
      end
      @esc.client.indices.create(index: index)
      @esc.client.indices.close(index: index)
      @esc.client.indices.put_settings(
        index: index,
        body: JSON.parse(File.read(
          'elasticsearch/standard_index_settings.json'))
      )
      @esc.client.indices.put_mapping(
        index: index,
        type: 'doc',
        body: JSON.parse(File.read(
          'elasticsearch/standard_index_mapping.json'))
      )
      @esc.client.indices.open(index: index)
    end

    def execute()
      response = RestClient.get(
        @dataspects_api_url,
        headers = {
          "dataspects-api-key": @dataspects_api_key,
          content_type: :json,
          accept: :json
        }
      )
      resources = JSON.parse(response)
      resources.each do |resource|
        esdoc = {
          # Resource silo level
          OriginatedFromResourceSiloID: "",
          OriginatedFromResourceSiloLabel: "",
          OriginatedFromResourceSiloType: "",
          # Resource level
          OriginatedFromResourceName: resource['pagename'],
          OriginatedFromResourceURL: "",
          OriginatedFromResourceType: "",
          # Entity/subject level
          HasEntityClass: resource['hasEntityClass'],
          HasEntityName: resource['hasEntityName'],
          HasEntityType: resource['hasEntityType'],
          HasEntityURL: resource['hasEntityURL'],
          HasEntityTitle: resource['hasEntityTitle'],
          HasEntityBlurbTEXT: resource['hasEntityBlurbTEXT'],
          HasEntityBlurbHTML: resource['hasEntityBlurbHTML'],
          HasEntityContentTEXT: "",
          HasEntityContentHTML: resource['nonFormssemanticizedWikitextHtml'],
          HasEntityTypeAndEntityTitle: "#{resource['hasEntityType']} \"resource['hasEntityTitle']\"",
          HasEntityKeywords: resource['hasEntityKeywords'],
          HasEntityAnnotations: resource['annotations']
        }

        # EVERYTHING to Elasticsearch
        @esc.index(
          body: esdoc,
          index: "dataspectspublic"
        )

        # ANNOTATIONS as Quads to MongoDB
        resource['annotations'].each do |annotation|
          # Can we create an index across models? In order to look up
          # HasEntityName for annotation['subject'] and annotation['object']

          subject = get(
            url: "http://localhost:3000/api/mediawikis/pages/"+annotation['subject'],
          )
          object = get(
            url: "http://localhost:3000/api/mediawikis/pages/"+annotation['object'],
          )

          quad = {
            id: "test",
            subject: annotation['subject'],
            subject_namespace: resource['mediaWiki']['namespace'],
            subject_class: "Entity|Subject", #
            subject_type: subject['hasEntityType'], #"Diagram|RubyGem" If annotation['subject'] exists in models:pagename then set to its hasEntityType
            predicate: annotation['predicate'],
            predicate_namespace: resource['mediaWiki']['namespace'],
            predicate_class: "Property|ActiveAction|PassiveAction",
            predicate_type: "Text|Page|URL",
            object: annotation['object'],
            object_namespace: "literal", # If annotation['object'] exists in models:pagename then set to resource['mediaWiki']['namespace']
            object_class: "Entity|Subject|literal",
            object_type: object['hasEntityType'], #"Diagram|RubyGem|literal" If annotation['object'] exists in models:pagename then set to its hasEntityType
            context: "test"
          }
          post(
            url: "http://localhost:3000/api/quads",
            body: quad.to_json
          )
        end
      end
    end

  end
end

# Run by "ruby index_cookbook_entities.rb"
$development_tika_url = "http://localhost:9998"
mwsi = Dataspects::CookbookFALnetIndexer.new(
  dataspects_api_url: "http://localhost:3000/api/mediawikis/5c8e750e1446664c692765f1/pages",
  dataspects_api_key: "aslkdjasldkjlaskdj",
  tika_url: $development_tika_url,
  es_url: "http://localhost:9200"
).execute
